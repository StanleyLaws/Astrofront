@namespace Astrofront
@using Sandbox
@using System.Linq
@inherits PanelComponent

@if ( !IsOpen )
{
    return;
}

<div class="ground-items-root">

    <div class="ground-items-header">
        <span class="ground-items-title">GROUND ITEMS</span>
    </div>

    <div class="ground-items-subheader">
        <div class="pager-controls">
            <div class="page-indicator">@($"{CurrentPage + 1}/{TotalPages}")</div>

            <div class="pager-buttons">
                <div class="page-btn @(CurrentPage <= 0 ? "disabled" : "")" @onclick="PrevPage">Prev</div>
                <div class="page-btn @(CurrentPage >= TotalPages - 1 ? "disabled" : "")" @onclick="NextPage">Next</div>
            </div>
        </div>
    </div>

    <div class="grid-4x4">
        @for ( var localIndex = 0; localIndex < PageSize; localIndex++ )
        {
            var globalIndex = (CurrentPage * PageSize) + localIndex;

            var slot = (globalIndex >= 0 && globalIndex < Slots.Count) ? Slots[globalIndex] : default;
            var hasItem = !string.IsNullOrEmpty( slot.ItemId ) && slot.Amount > 0;

            <GroundItemSlot
                SlotIndex="@globalIndex"
                ItemId="@(slot.ItemId ?? "")"
                Amount="@(slot.Amount)"
                HasItem="@hasItem" />
        }
    </div>

</div>

@code
{
    public static GroundItemsPanel Instance { get; private set; }

    private const int PageSize = 16;
    private int CurrentPage = 0;

    public bool IsOpen { get; private set; } = false;

    public struct SlotData
    {
        public string ItemId;
        public int Amount;
    }

    public List<SlotData> Slots { get; set; } = new();

    private RealTimeSince _sinceRefresh;

    public GroundItemsPanel()
    {
        Instance = this;
    }

    protected override void OnUpdate()
    {
        base.OnUpdate();

        if ( !IsOpen ) return;

        if ( _sinceRefresh > 0.3f )
        {
            _sinceRefresh = 0;
            GroundItemsService.RefreshLootForLocal();
        }
    }

    private int TotalPages
    {
        get
        {
            var count = Slots?.Count ?? 0;
            if ( count <= 0 ) return 1;
            return (int)System.Math.Ceiling( count / (float)PageSize );
        }
    }

    private void PrevPage()
    {
        if ( CurrentPage <= 0 ) return;
        CurrentPage--;
        StateHasChanged();
    }

    private void NextPage()
    {
        if ( CurrentPage >= TotalPages - 1 ) return;
        CurrentPage++;
        StateHasChanged();
    }

    public static void Show( GroundItemDto[] items )
    {
        if ( Instance == null ) return;

        Instance.BuildSlots( items );
        Instance.IsOpen = true;
        Instance.ClampPage();
        Instance.StateHasChanged();

        Log.Info( $"[GroundItemsPanel] Show items={items?.Length ?? 0}" );
    }

    public static void Hide()
    {
        if ( Instance == null ) return;

        Instance.IsOpen = false;
        Instance.StateHasChanged();

        // Option: Clear main quand on ferme le loot
        // UiDragContext.Clear();
    }

    private void ClampPage()
    {
        var max = System.Math.Max( 0, TotalPages - 1 );
        if ( CurrentPage > max ) CurrentPage = max;
        if ( CurrentPage < 0 ) CurrentPage = 0;
    }

    private void BuildSlots( GroundItemDto[] items )
    {
        Slots.Clear();

        // Si on tient déjà du loot en main, on le “cache” de la liste
        int heldToHide = 0;
        string heldId = "";

        if ( UiDragContext.HasItem && UiDragContext.SourceKind == UiDragSourceKind.LootPanel )
        {
            heldId = UiDragContext.HeldItemId;
            heldToHide = UiDragContext.HeldAmount;
        }

        if ( items != null && items.Length > 0 )
        {
            // Groupe par ItemId (pas par GO)
            var grouped = items
                .Where( it => !string.IsNullOrEmpty( it.ItemId ) && it.Amount > 0 )
                .GroupBy( it => it.ItemId )
                .Select( g =>
                {
                    int total = g.Sum( x => x.Amount );

                    if ( g.Key == heldId && heldToHide > 0 )
                    {
                        int hide = System.Math.Min( total, heldToHide );
                        total -= hide;
                        heldToHide -= hide;
                    }

                    return new SlotData { ItemId = g.Key, Amount = total };
                })
                .Where( s => s.Amount > 0 )
                .ToList();

            Slots.AddRange( grouped );
        }

        // Padding pages
        if ( Slots.Count <= 0 )
        {
            for ( int i = 0; i < PageSize; i++ )
                Slots.Add( default );
        }
        else
        {
            int rem = Slots.Count % PageSize;
            if ( rem != 0 )
            {
                int need = PageSize - rem;
                for ( int i = 0; i < need; i++ )
                    Slots.Add( default );
            }
        }

        ClampPage();
    }

    public void OnDragDrop( int fromIndex, int toIndex )
    {
        // UI-only reorder (cosmétique)
        if ( fromIndex < 0 || fromIndex >= Slots.Count ) return;
        if ( toIndex < 0 || toIndex >= Slots.Count ) return;
        if ( fromIndex == toIndex ) return;

        var tmp = Slots[fromIndex];
        Slots[fromIndex] = Slots[toIndex];
        Slots[toIndex] = tmp;

        StateHasChanged();
    }

    public void OnSlotClick( int index, string button )
    {
        if ( index < 0 || index >= Slots.Count ) return;

        var slot = Slots[index];
        bool primary = button == "mouseleft";
        bool secondary = button == "mouseright";

        if ( !primary && !secondary ) return;

        bool slotHasItem = !string.IsNullOrEmpty( slot.ItemId ) && slot.Amount > 0;

        // Main vide => prendre
        if ( !UiDragContext.HasItem )
        {
            if ( !slotHasItem ) return;

            if ( primary )
            {
                UiDragContext.BeginHold( slot.ItemId, slot.Amount, UiDragSourceKind.LootPanel, index );
                Slots[index] = default;
                StateHasChanged();
                return;
            }

            if ( secondary )
            {
                UiDragContext.BeginHold( slot.ItemId, 1, UiDragSourceKind.LootPanel, index );
                slot.Amount -= 1;
                Slots[index] = (slot.Amount <= 0) ? default : slot;
                StateHasChanged();
                return;
            }
        }

        // Main pleine => déposer sur le sol
        if ( primary )
            HandlePrimaryPlace( slot, index );
        else
            HandleSecondaryPlace( slot, index );

        StateHasChanged();
    }

    private void HandlePrimaryPlace( SlotData slot, int index )
    {
        if ( !UiDragContext.HasItem ) return;

        var heldId = UiDragContext.HeldItemId;
        var heldAmount = UiDragContext.HeldAmount;
        var fromInventory = UiDragContext.SourceKind == UiDragSourceKind.Inventory;

        if ( string.IsNullOrEmpty( heldId ) || heldAmount <= 0 )
        {
            UiDragContext.Clear();
            return;
        }

        bool slotHasItem = !string.IsNullOrEmpty( slot.ItemId ) && slot.Amount > 0;

        if ( !slotHasItem )
        {
            Slots[index] = new SlotData { ItemId = heldId, Amount = heldAmount };
            UiDragContext.Clear();

            if ( fromInventory )
                UiLootInventoryBridge.RequestSpawnToWorld( heldId, heldAmount );

            return;
        }

        if ( slot.ItemId == heldId )
        {
            slot.Amount += heldAmount;
            Slots[index] = slot;
            UiDragContext.Clear();

            if ( fromInventory )
                UiLootInventoryBridge.RequestSpawnToWorld( heldId, heldAmount );

            return;
        }

        // swap (UI)
        var tmpId = slot.ItemId;
        var tmpAmt = slot.Amount;

        Slots[index] = new SlotData { ItemId = heldId, Amount = heldAmount };
        UiDragContext.BeginHold( tmpId, tmpAmt, UiDragSourceKind.LootPanel, index );

        if ( fromInventory )
            UiLootInventoryBridge.RequestSpawnToWorld( heldId, heldAmount );
    }

    private void HandleSecondaryPlace( SlotData slot, int index )
    {
        if ( !UiDragContext.HasItem ) return;

        var heldId = UiDragContext.HeldItemId;
        var heldAmount = UiDragContext.HeldAmount;
        var fromInventory = UiDragContext.SourceKind == UiDragSourceKind.Inventory;

        if ( string.IsNullOrEmpty( heldId ) || heldAmount <= 0 )
        {
            UiDragContext.Clear();
            return;
        }

        bool slotHasItem = !string.IsNullOrEmpty( slot.ItemId ) && slot.Amount > 0;

        if ( !slotHasItem )
        {
            Slots[index] = new SlotData { ItemId = heldId, Amount = 1 };
            UiDragContext.TakeFromHand( 1 );

            if ( fromInventory )
                UiLootInventoryBridge.RequestSpawnToWorld( heldId, 1 );

            return;
        }

        if ( slot.ItemId == heldId )
        {
            slot.Amount += 1;
            Slots[index] = slot;

            UiDragContext.TakeFromHand( 1 );

            if ( fromInventory )
                UiLootInventoryBridge.RequestSpawnToWorld( heldId, 1 );

            return;
        }
    }
}
