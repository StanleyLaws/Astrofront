@namespace Astrofront
@using Sandbox
@using System.Linq
@inherits PanelComponent

@if ( !IsOpen )
{
    return;
}

<div class="invmanage-root">
    <div class="invmanage-header">
        <span class="title">Inventory</span>
    </div>

    <div class="invmanage-bar">
        @for ( int i = 0; i < _slotCount; i++ )
        {
            var isHands = (i == 0);

            var slot = _slots[i];
            var itemId = slot.ItemId;
            var amount = slot.Amount;

            var hasItem = !isHands && !string.IsNullOrEmpty( itemId ) && amount > 0;

            <InventoryManageSlot
                SlotIndex="@i"
                Locked="@isHands"
                HasItem="@hasItem"
                ItemId="@(hasItem ? itemId : "")"
                Amount="@(hasItem ? amount : 0)" />
        }
    </div>
</div>

@code
{
    public static InventoryManagePanel Instance { get; private set; }

    public bool IsOpen { get; private set; } = false;

    private InventoryComponent _inv;

    private int _slotCount = 5;
	
	private int _lastDragVersion = -1;

    private struct SlotView
    {
        public string ItemId;
        public int Amount;
    }

    private SlotView[] _slots = new SlotView[5];

    public InventoryManagePanel()
    {
        Instance = this;
    }

    protected override void OnStart()
    {
        BindLocalInventory();
        PullSlots();
    }

    protected override void OnUpdate()
	{
		if ( _inv == null )
		{
			BindLocalInventory();
			return;
		}

		// ✅ Si la main fantôme change (begin/clear/take), on refresh l'affichage
		// pour que l'overlay visuel reste cohérent même quand le snapshot arrive avant le callback.
		if ( _lastDragVersion != UiDragContext.Version )
		{
			_lastDragVersion = UiDragContext.Version;
			PullSlots();
			StateHasChanged();
		}
	}


    protected override void OnDestroy()
    {
        if ( _inv != null )
        {
            _inv.SelectionChanged -= OnSelectionChanged;
            _inv.SlotsChanged     -= OnSlotsChanged;
        }

        _inv = null;
    }

    private void BindLocalInventory()
    {
        if ( _inv != null ) return;

        var scene = Scene ?? Game.ActiveScene;
        if ( scene == null ) return;

        var ps = scene.GetAllComponents<PlayerState>()
            .FirstOrDefault( p => p != null
                              && !p.IsProxy
                              && p.GameObject != null
                              && (p.GameObject.Tags.Has("localplayer")
                                  || (Connection.Local != null && p.Network?.Owner == Connection.Local)) );

        if ( ps == null ) return;

        _inv = ps.GameObject.Components.Get<InventoryComponent>( FindMode.EverythingInSelfAndDescendants );
        if ( _inv == null ) return;

        _slotCount = _inv.SlotCount;
        _slots = new SlotView[_slotCount];

        _inv.SelectionChanged += OnSelectionChanged;
        _inv.SlotsChanged     += OnSlotsChanged;

        PullSlots();
        StateHasChanged();

        Log.Info( "[InventoryManagePanel] Bound InventoryComponent local owner." );
    }

    private void PullSlots()
	{
		if ( _inv == null ) return;

		var snap = _inv.GetSlotsSnapshot();
		if ( snap == null || snap.Count <= 0 ) return;

		_slotCount = snap.Count;

		if ( _slots == null || _slots.Length != _slotCount )
			_slots = new SlotView[_slotCount];

		bool hideFromInv = UiDragContext.HasItem
			&& UiDragContext.SourceKind == UiDragSourceKind.Inventory
			&& UiDragContext.SourceIndex >= 0
			&& UiDragContext.SourceIndex < _slotCount;

		int hideIndex = hideFromInv ? UiDragContext.SourceIndex : -1;
		string hideId = hideFromInv ? UiDragContext.HeldItemId : "";
		int hideAmt = hideFromInv ? UiDragContext.HeldAmount : 0;

		for ( int i = 0; i < _slotCount; i++ )
		{
			var (id, amt) = snap[i];

			id ??= "";
			int shownAmt = amt;

			if ( i == hideIndex
				 && !string.IsNullOrEmpty( hideId )
				 && string.Equals( id, hideId, System.StringComparison.OrdinalIgnoreCase )
				 && hideAmt > 0 )
			{
				shownAmt = System.Math.Max( 0, amt - hideAmt );

				if ( shownAmt <= 0 )
				{
					shownAmt = 0;
					id = "";
				}
			}

			_slots[i] = new SlotView { ItemId = id, Amount = shownAmt };
		}
	}



    private void OnSelectionChanged( int idx )
    {
        PullSlots();
        StateHasChanged();
    }

    private void OnSlotsChanged()
    {
        PullSlots();
        StateHasChanged();
    }

    // =========================
    // API appelée par les Slots
    // =========================

    public void OnDragDrop( int fromIndex, int toIndex )
    {
        if ( _inv == null ) return;

        if ( fromIndex == 0 || toIndex == 0 ) return;
        if ( fromIndex < 0 || toIndex < 0 || fromIndex >= _slotCount || toIndex >= _slotCount ) return;
        if ( fromIndex == toIndex ) return;

        _inv.RequestSwapHost( fromIndex, toIndex );
    }

    public void OnSlotPrimaryClick( int index )
{
    if ( _inv == null ) return;
    if ( index == 0 ) return;
    if ( index < 0 || index >= _slotCount ) return;

    PullSlots();
    var slot = _slots[index];
    bool slotHasItem = !string.IsNullOrEmpty( slot.ItemId ) && slot.Amount > 0;

    // 1) Main vide -> prendre tout (UI only)
    if ( !UiDragContext.HasItem )
    {
        if ( !slotHasItem ) return;

        UiDragContext.BeginHold( slot.ItemId, slot.Amount, UiDragSourceKind.Inventory, index );

        // ✅ refresh immédiat pour appliquer l'overlay visuel (slot "vidé")
        PullSlots();
        StateHasChanged();
        return;
    }

    // 2) Main pleine -> placer / annuler
    var heldId = UiDragContext.HeldItemId;
    var heldAmount = UiDragContext.HeldAmount;

    if ( heldAmount <= 0 || string.IsNullOrEmpty( heldId ) )
    {
        UiDragContext.Clear();
        PullSlots();
        StateHasChanged();
        return;
    }

    // Si la main vient du loot -> transaction serveur anti-dup
    if ( UiDragContext.SourceKind == UiDragSourceKind.LootPanel )
    {
        UiLootInventoryBridge.RequestLootToInventory( heldId, heldAmount, index );
        return;
    }

    // ✅ Cas important (ton besoin) :
    // Si la main vient de l'inventaire et qu'on reclique le slot source -> on "repose" = cancel UI
    if ( UiDragContext.SourceKind == UiDragSourceKind.Inventory
         && UiDragContext.SourceIndex == index )
    {
        UiDragContext.Clear();
        PullSlots();
        StateHasChanged();
        return;
    }

    // Main vient de l'inventaire -> transaction atomique host
    // Autorise uniquement slot vide ou même item (swap via drag&drop)
    if ( !slotHasItem || slot.ItemId == heldId )
    {
        _inv.RequestMoveHeldHost( UiDragContext.SourceIndex, index, heldAmount );
        return;
    }

    // item différent : pas d'action en clic (swap via drag&drop)
}



    public void OnSlotSecondaryClick( int index )
{
    if ( _inv == null ) return;
    if ( index == 0 ) return;
    if ( index < 0 || index >= _slotCount ) return;

    PullSlots();
    var slot = _slots[index];
    bool slotHasItem = !string.IsNullOrEmpty( slot.ItemId ) && slot.Amount > 0;

    // 1) Main vide -> prendre 1 (UI only)
    if ( !UiDragContext.HasItem )
    {
        if ( !slotHasItem ) return;

        UiDragContext.BeginHold( slot.ItemId, 1, UiDragSourceKind.Inventory, index );

        // ✅ refresh immédiat pour appliquer l'overlay visuel (slot réduit)
        PullSlots();
        StateHasChanged();
        return;
    }

    // 2) Main pleine -> placer 1 / annuler
    var heldId = UiDragContext.HeldItemId;
    var heldAmount = UiDragContext.HeldAmount;

    if ( heldAmount <= 0 || string.IsNullOrEmpty( heldId ) )
    {
        UiDragContext.Clear();
        PullSlots();
        StateHasChanged();
        return;
    }

    // Loot -> inventaire (1)
    if ( UiDragContext.SourceKind == UiDragSourceKind.LootPanel )
    {
        UiLootInventoryBridge.RequestLootToInventory( heldId, 1, index );
        return;
    }

    // ✅ Cas important :
    // clic droit sur le slot source = "remettre 1" => en pratique cancel UI si tu veux le même feeling.
    // (tu peux aussi choisir de clear seulement si HeldAmount==1, mais je reste simple)
    if ( UiDragContext.SourceKind == UiDragSourceKind.Inventory
         && UiDragContext.SourceIndex == index )
    {
        UiDragContext.Clear();
        PullSlots();
        StateHasChanged();
        return;
    }

    // Inventaire -> inventaire : transaction atomique host (1)
    if ( !slotHasItem || slot.ItemId == heldId )
    {
        _inv.RequestMoveHeldHost( UiDragContext.SourceIndex, index, 1 );
        return;
    }

    // slot différent : on ne fait rien en secondaire
}



    // =========================
    // Ouverture / Fermeture
    // =========================
    public static void Show()
    {
        if ( Instance == null ) return;

        if ( Instance._inv == null )
            Instance.BindLocalInventory();

        Instance.PullSlots();
		Instance._lastDragVersion = UiDragContext.Version;
        Instance.IsOpen = true;
        Instance.StateHasChanged();
    }

    public static void Hide()
    {
        if ( Instance == null ) return;

        // ✅ main inventaire = UI only -> on clear simplement
        if ( UiDragContext.HasItem && UiDragContext.SourceKind == UiDragSourceKind.Inventory )
        {
            UiDragContext.Clear();
        }

        Instance.IsOpen = false;
        Instance.StateHasChanged();
    }

}
